'''Home of the CrunchCube class.

This module contains the definition of the CrunchCube class. It represents
the open-source library used for manipulating the crunch cubes (JSON responses
from the Crunch.io platform).
'''
from __future__ import division

import json

import numpy as np
from scipy.stats import norm
from scipy.stats.contingency import expected_freq

from .measures.data_table import DataTable
from .measures.index import Index
from .measures.scale_means import ScaleMeans

np.seterr(divide='ignore', invalid='ignore')


class CrunchCube(object):
    '''Implementation of the CrunchCube API class.

    Class is used for the implementation of the main API functions that are
    needed for seamless integration with the crunch cube responses
    (from Crunch.io platform).

    Main API functions are:
      - as_array
      - margin
      - proportions
      - percentages

    These functions are used to retrieve statistical information of interest,
    from the JSON like crunch cubes. Complete usage of each API function is
    described within the appropriate docstring.

    Crunch Cubes contain richer metadata than standart Python objects, and
    they also conceal certain complexity in the data structures from the user.
    In particular, Multiple Response variables are generally represented as
    single dimensions in result tables, but in the actual data, they may
    comprise of two dimensions. These methods (API) understand the subtleties
    in the Crunch data types, and correctly compute margins and
    percentages off of them.
    '''

    def __init__(self, response):
        '''Initializes the CrunchCube class with the cube JSON response.

        Class can be initialized with both JSON string, and dict types.
        There's no real parsing of the data at the point of initialization,
        just storing. The functionality is implemented in the
        appropriate API functions.

        @response: Represents the cube response object, as generated by the
            zz9d cube factory. Cube can come in as a JSON or as a dictionary,
            So we need to check its type, and convert it to a dictionary if
            it's JSON, if possible.
        '''

        # If the provided response is dict, create cube immediately
        if isinstance(response, dict):
            self._table = DataTable(response.get('value', response))
            return

        try:
            response = json.loads(response)
            self._table = DataTable(response.get('value', response))
        except TypeError:
            # If an unexpected type is provided raise descriptive exception.
            if not isinstance(response, dict):
                raise TypeError((
                    'Unsupported type provided: {}. '
                    'A `cube` must be JSON or `dict`.'
                ).format(type(response)))

    def _get_valid_indices(self, dimensions, include_missing,
                           get_non_selected=False, get_all_mr=False):
        '''Gets valid indices for each dimension.

        Main criterion for a valid index is most often the information about
        whether the corresponding value of the dimension is missing or not.
        For MR variables, since they use two dimensions, the valid index
        for the 'selections' dimensions is [0], except in the case of
        non-selected slices calculation, where it needs to be [1].
        '''
        valid_indices = [dim.valid_indices(include_missing)
                         for dim in dimensions]

        mr_selections_indices = self.table.mr_selections_indices
        mr_slice = [0]
        if get_all_mr:
            mr_slice = [0, 1, 2]
        elif get_non_selected:
            mr_slice = [1]

        if mr_selections_indices:
            # In the case of MR variables, we only need to select the
            # 'selected' slice of the 'selections' dimension.
            valid_indices = [
                (
                    valid_indices[i]
                    if i not in mr_selections_indices
                    else mr_slice
                )
                for (i, _) in enumerate(valid_indices)
            ]

        return valid_indices

    @classmethod
    def _fix_shape(cls, array):
        '''Fixes shape of MR variables.
        For MR variables, where 'selections' dims are dropped, the ndarray
        needs to be reshaped, in order to seem as if those dims never existed.

        Also, if any (except 1st) dimension has a single element, it is
        flattened in the resulting array (which is more convenient for the
        users of the CrunchCube). If the original shape of the cube is
        needed (e.g. to calculate the margins with correct axis arguments),
        this needs to happen before the call to this method '_fix_shape'. In
        general, use private methods, if operating inside CrunchCube. API
        methods should only be used from outside CrunchCube.
        '''

        # If a first dimension only has one element, we don't want to
        # remove it from the shape. Hence the i == 0 part.
        new_shape = [dim for (i, dim) in enumerate(array.shape)
                     if dim != 1 or i == 0]
        return array.reshape(new_shape)

    def _update_result(self, result, insertions, dimension_index,
                       valid_indices):
        '''Insert subtotals into resulting ndarray.'''
        for j, (ind_insertion, value) in enumerate(insertions):
            result = np.insert(
                result, ind_insertion + j + 1, value, axis=dimension_index
            )
            valid_indices = (
                valid_indices and
                self._fix_valid_indices(
                    valid_indices, ind_insertion + j, dimension_index
                )
            )
        return result, valid_indices

    def _transform(self, res, include_transforms_for_dims, valid_indices,
                   inflate=False):
        '''Transform the shape of the resulting ndarray.'''
        if not include_transforms_for_dims:
            return res[np.ix_(*valid_indices)] if valid_indices else res

        dim_offset = 0
        dims = self.table.all_dimensions if self.has_mr else self.dimensions
        for (i, dim) in enumerate(dims):
            # Check if transformations can/need to be performed
            transform = (dim.has_transforms and
                         i - dim_offset in include_transforms_for_dims)
            if dim.type == 'multiple_response':
                dim_offset += 1
            if not transform or dim.type == 'categorical_array':
                continue
            # Perform transformations
            insertions = self._insertions(res, dim, i)
            ind = i if inflate else i - dim_offset
            res, valid_indices = self._update_result(
                res, insertions, ind, valid_indices
            )
        return res[np.ix_(*valid_indices)] if valid_indices else res

    def _as_array(self, include_missing=False, get_non_selected=False,
                  weighted=True, adjusted=False,
                  include_transforms_for_dims=False,
                  prune=False, margin=False):
        '''Get crunch cube as ndarray.

        Args
            include_missing (bool): Include rows/cols for missing values.
            get_non_selected (bool): Get non-selected slices for MR vars.
            weighted (bool): Take weighted or unweighted counts.
            adjusted (bool): If adjusted, add + 1 to the resulting array. This
                is needed when calculating statistical signifficance.
            include_transforms_for_dims (list): For which dims to
                include headings & subtotals (H&S) transformations.
            prune (bool): Prune rows and columns for which corresponding
                marginal values are 0 (or not defined / np.nan)
            margin (bool): Designates whether array is intented for margin
                calculation. This essentially tells the CrunchCube to use
                counts (and not means, or other measures) as the result.
        Returns
            res (ndarray): Tabular representation of crunch cube
        '''

        values = self.table.flat_values(weighted, margin)
        dimensions = self.table.all_dimensions
        shape = [len(dim.elements(include_missing=True)) for dim in dimensions]
        valid_indices = self._get_valid_indices(dimensions, include_missing,
                                                get_non_selected)
        res = np.array(values).reshape(shape)
        res = self._transform(
            res, include_transforms_for_dims, valid_indices, inflate=True
        )
        res = res + adjusted

        if prune:
            return self._prune_body(res, include_transforms_for_dims)

        return res

    def _prune_3d_body(self, res, transforms):
        mask = np.zeros(res.shape)
        for i, prune_inds in enumerate(self.prune_indices(transforms)):
            rows_pruned = prune_inds[0]
            cols_pruned = prune_inds[1]
            rows_pruned = np.repeat(
                rows_pruned[:, None], len(cols_pruned), axis=1
            )
            cols_pruned = np.repeat(
                cols_pruned[None, :], len(rows_pruned), axis=0
            )
            slice_mask = np.logical_or(rows_pruned, cols_pruned)

            # In case of MRs we need to "inflate" mask
            if self.mr_dim_ind == (1, 2):
                slice_mask = slice_mask[:, np.newaxis, :, np.newaxis]
            elif self.mr_dim_ind == (0, 1):
                slice_mask = slice_mask[np.newaxis, :, np.newaxis, :]
            elif self.mr_dim_ind == (0, 2):
                slice_mask = slice_mask[np.newaxis, :, :, np.newaxis]

            mask[i] = slice_mask
        res = np.ma.masked_array(res, mask=mask)
        return res

    def _prune_body(self, res, transforms=None):
        '''Prune the result based on margins content.

        Pruning is the removal of rows or columns, whose corresponding
        marginal elements are either 0 or not defined (np.nan).
        '''

        if self.ndim > 2:
            return self._prune_3d_body(res, transforms)

        # Note: If the cube contains transforms (H&S), and they happen to
        # have the marginal value 0 (or NaN), they're NOT pruned. This is
        # done to achieve parity with how the front end client works (whaam).
        row_margin = self.margin(
            include_transforms_for_dims=transforms,
            axis=self.row_direction_axis
        )
        if row_margin.ndim > 1:
            # In case of CAT x MR, we have 2D margin
            row_margin = np.sum(row_margin, axis=1)
        row_prune_inds = self._margin_pruned_indices(
            row_margin,
            self.inserted_dim_inds(transforms, 0)
        )

        if self.ndim == 1 or len(res.shape) == 1:
            # For 1D, margin is calculated as the row margin.
            return np.ma.masked_array(res, mask=row_prune_inds)

        # Prune columns by column margin values.
        col_margin = self.margin(
            include_transforms_for_dims=transforms,
            axis=self.col_direction_axis,
        )
        if col_margin.ndim > 1:
            # In case of MR x CAT, we have 2D margin
            col_margin = np.sum(col_margin, axis=0)
        col_prune_inds = self._margin_pruned_indices(
            col_margin,
            self.inserted_dim_inds(transforms, 1)
        )
        mask = self._create_mask(res, row_prune_inds, col_prune_inds)
        res = np.ma.masked_array(res, mask=mask)
        return res

    @staticmethod
    def _create_mask(res, row_prune_inds, col_prune_inds):
        mask_rows = np.repeat(
            row_prune_inds[:, None], len(col_prune_inds), axis=1
        )
        mask_cols = np.repeat(
            col_prune_inds[None, :], len(row_prune_inds), axis=0
        )
        return np.logical_or(mask_rows, mask_cols)

    def prune_indices(self, transforms=None):
        '''Indices of pruned rows and columns.

        Returns:
            (list) One of the possible lists:

            - 1-element list of row indices (in case of 1D cube)
            - 2-element list of row and col indices (in case of 2D cube)
            - n-element list of tuples of 2 elements (if it's 3D cube).
            For each case, the 2 elements are the ROW and COL indices of the
            elements that need to be pruned. If it's a 3D cube, these indices
            are calculated "per slice", that is NOT on the 0th dimension
            (as the 0th dimension represents the slices).
        '''
        if self.ndim >= 3:
            # In case of a 3D cube, return list of tuples
            # (of row and col pruned indices).
            return self._prune_3d_indices(transforms)

        # In case of 1 or 2 D cubes, return a list of
        # row indices (or row and col indices)
        return self._prune_indices(transforms)

    def _prune_indices(self, transforms):
        row_margin = self.margin(
            include_transforms_for_dims=transforms,
            axis=self.row_direction_axis
        )
        row_indices = self._margin_pruned_indices(
            row_margin,
            self.inserted_dim_inds(transforms, 0)
        )
        if row_indices.ndim > 1:
            # In case of MR, we'd have 2D prune indices
            row_indices = row_indices.all(axis=1)

        if self.ndim == 1:
            return [row_indices]

        col_margin = self.margin(
            include_transforms_for_dims=transforms,
            axis=self.col_direction_axis,
        )
        col_indices = self._margin_pruned_indices(
            col_margin,
            self.inserted_dim_inds(transforms, 1)
        )
        if col_indices.ndim > 1:
            # In case of MR, we'd have 2D prune indices
            col_indices = col_indices.all(axis=0)

        return [row_indices, col_indices]

    def _prune_3d_indices(self, transforms):
        row_margin = self.margin(
            include_transforms_for_dims=transforms,
            axis=self.row_direction_axis
        )
        col_margin = self.margin(
            include_transforms_for_dims=transforms,
            axis=self.col_direction_axis,
        )
        return [
            self._prune_indices_tuple(rm, cm, transforms)
            for rm, cm in zip(row_margin, col_margin)
        ]

    def _prune_indices_tuple(self, row_margin, column_margin, transforms):
        if row_margin.ndim > 1:
            row_margin = np.sum(row_margin, axis=1)
        if column_margin.ndim > 1:
            column_margin = np.sum(column_margin, axis=0)

        row_inserted_indices = (
            self.inserted_dim_inds(transforms, 0)
        )
        col_inserted_indices = (
            self.inserted_dim_inds(transforms, 1)
        )

        return (
            self._margin_pruned_indices(row_margin, row_inserted_indices),
            self._margin_pruned_indices(column_margin, col_inserted_indices),
        )

    @property
    def row_direction_axis(self):
        # when dealing with 1D MR cubes, axis for margin should be 0
        if self.ndim == 1 and self.has_mr:
            return 0
        elif self.ndim == 3 and not self.is_double_mr:
            return 2
        return 1

    def inserted_dim_inds(self, transforms, dim):
        if not transforms:
            return []
        inserted_inds = self.inserted_hs_indices()
        if dim == 0:  # In case of row
            dim_ind = 0 if self.ndim < 3 else 1
        elif dim == 1:
            dim_ind = 1
        return np.array(
            inserted_inds[dim_ind] if len(inserted_inds) else []
        )

    @staticmethod
    def _margin_pruned_indices(margin, insertions):
        ind_inserted = np.zeros(margin.shape, dtype=bool)
        if insertions is not None and any(insertions):
            ind_inserted[insertions] = True
        pruned_ind = np.logical_or(margin == 0, np.isnan(margin))
        pruned_ind = np.logical_and(pruned_ind, ~ind_inserted)

        return pruned_ind

    @property
    def col_direction_axis(self):
        return self.ndim - 2

    @classmethod
    def _fix_valid_indices(cls, valid_indices, insertion_index, dim):
        '''Add indices for H&S inserted elements.'''
        indices = np.array(sorted(valid_indices[dim]))
        slice_index = np.sum(indices <= insertion_index)
        indices[slice_index:] += 1
        indices = np.insert(indices, slice_index, insertion_index + 1)
        valid_indices[dim] = indices.tolist()
        return valid_indices

    @classmethod
    def _calculate_constraints_sum(cls, prop_table, prop_margin, axis):
        '''Calculate sum of constraints (part of the standard error equation).

        This method calculates the sum of the cell proportions multiplied by
        row (or column) marginal proportions (margins divide by the total
        count). It does this by utilizing the matrix multiplication, which
        directly translates to the mathematical definition (the sum
        across i and j indices).
        '''
        if axis not in [0, 1]:
            raise ValueError('Unexpected value for `axis`: {}'.format(axis))

        V = prop_table * (1 - prop_table)
        if axis == 0:
            # If axis is 0, sumation is performed across the 'i' index, which
            # requires the matrix to be multiplied from the right
            # (because of the inner matrix dimensions).
            return np.dot(V, prop_margin)
        elif axis == 1:
            # If axis is 1, sumation is performed across the 'j' index, which
            # requires the matrix to be multiplied from the left
            # (because of the inner matrix dimensions).
            return np.dot(prop_margin, V)

    def _double_mr_proportions(self, axis, weighted):
        '''Return proportions for MR x MR cube.

        Double MR cubes internally have 4 dimensions, and they're quite specific
        in how they output their values. Thus the separate method.
        '''
        num = self.as_array()
        den = self.margin(axis=axis if axis != 2 else None)

        if axis == 1 and self.ndim > 2:
            den = np.sum(den, 0)
        elif axis != 2 and self.ndim > 2:
            den = np.sum(self.margin(), 0)

        return num / den

    def _double_mr_margin(self, axis, weighted):
        '''Margin for MR x MR cube (they're specific, thus separate method).'''
        table = self.table.data(weighted)
        ind_ns, ind_ns_0, ind_ns_1 = self.double_mr_non_selected_inds
        selected = table[self.ind_selected]
        non_selected = table[ind_ns]

        if axis is None:
            non_selected += table[ind_ns_1] + table[ind_ns_0]
        elif axis == 0:
            non_selected = table[ind_ns_1]
        elif axis == 1:
            non_selected = table[ind_ns_0]

        return (selected + non_selected)[np.ix_(*self.valid_indices)]

    def _1d_mr_margin(self, axis, weighted):
        table = self.table.data(weighted)
        if axis == 0:
            return self.as_array(weighted=weighted)
        return table[:, 0] + table[:, 1]

    def _calculate_along_non_mr(self, axis):
        return (
            self.mr_dim_ind in [0, 2] and axis == 1 or
            self.mr_dim_ind == 1 and axis == 0 or
            self.mr_dim_ind == 1 and axis == 1 and self.ndim > 2
        )

    def _mr_margin_along_non_mr_dim(self, axis, weighted,
                                    include_transforms_for_dims=None):
        '''Calculate MR margin along non-MR dimension.

        For cases when margin is calculated along the axis which is not MR,
        we need to perform sumation along that axis, on the tabular
        representation of the cube (which is obtained with 'as_array').
        '''
        array = self.as_array(
            weighted=weighted,
            include_transforms_for_dims=include_transforms_for_dims,
            margin=True,
        )

        if axis == 1 and len(array.shape) == 1:
            # If array representation of the cube has less dimensions than
            # supposed (by the 'axis' argument), return the array. This
            # condition may arise if one of the cross variables of the cube
            # has only one element (e.g. in MR x CAT cube).
            return array

        return np.sum(array, axis)

    def _get_mr_slice(self, selected=True):
        index = 0 if selected else 1
        indices = []
        for dim in self.dimensions:
            if dim.type == 'multiple_response':
                indices.extend([slice(None), index])
            else:
                indices.append(slice(None))
        return tuple(indices)

    def _transform_table(self, table, include_transforms_for_dims):
        valid_indices = self._get_valid_indices(
            self.table.all_dimensions,
            include_missing=False,
            get_all_mr=True
        )
        table = self._transform(
            table,
            include_transforms_for_dims,
            valid_indices,
            inflate=True
        )
        return table

    def _mr_margin(self, axis, weighted, adjusted,
                   include_transforms_for_dims=None, prune=False):
        '''Margin for cube that contains MR.'''
        if self.is_double_mr:
            return self._double_mr_margin(axis, weighted)
        elif self.ndim == 1:
            return self._1d_mr_margin(axis, weighted)
        elif self._calculate_along_non_mr(axis):
            return self._mr_margin_along_non_mr_dim(axis, weighted,
                                                    include_transforms_for_dims)

        table = self.table.data(weighted, margin=True)
        if include_transforms_for_dims:
            # In case of H&S the entire table needs to be
            # transformed (with selections).
            table = self._transform_table(table, include_transforms_for_dims)

        # For cases when the margin is calculated for the MR dimension, we need
        # the sum of selected and non-selected slices (if axis is None), or the
        # sublimated version (another sum along the axis), if axis is defined.
        margin = table[self.ind_selected] + table[self.ind_non_selected]
        if not include_transforms_for_dims:
            # If entire table was transformed, we already have it with all the
            # valid indices. If not, we need to apply valid indices.
            margin = margin[np.ix_(*self.valid_indices)]

        if axis is None:
            axis = tuple([
                i for i, _ in enumerate(self.dimensions) if i != self.mr_dim_ind
            ])
            return np.sum(margin, axis)

        if prune:
            mask = self.as_array(prune=True).mask
            margin = np.ma.masked_array(margin, mask=mask)

        return margin

    def _inflate_dim(self, array, axis):
        # Explicitly check if axis is tuple (which could be the case for doing
        # cell percentages across 3D cube, when the axis is set to (1, 2)).
        # Python 3 doesn't support tuple to int conversion, and we have to
        # check it manually.
        if (axis and not isinstance(axis, tuple) and
                axis > 0 and len(array.shape) == 1):
            # If any of the dimensions has only one element, it's flattened
            # from the resulting array (as a part of the MR pre-processing).
            # This can lead to a potential inconsistency between dimensions
            # and axes, and we need to restore one dimension in this case.
            array = array[:, np.newaxis]

        return array

    def _margin_transform_dims(self, axis, include_transforms_for_dims):
        # FIXME
        # This is an uglu hack and needs to be refactored. The issue is that
        # when calculating margins for some cases, we mustn't include _all_
        # transformations, because the numbers would be wrong. We then need a
        # smart way to figure out _only_ those transformations that need to be
        # included in the margin calculation.

        if len(self.dimensions) <= 2:
            return include_transforms_for_dims and (
                [(1 - axis)]
                if axis is not None and isinstance(axis, int) else
                None
            )
        return include_transforms_for_dims

    def _margin(self, axis=None, weighted=True, adjusted=False,
                include_transforms_for_dims=None, prune=False):

        # MR margins are calculated differently, so they need a separate method
        # for them. A good example of this is the rcrunch functionality.
        if self.has_mr:
            return self._mr_margin(
                axis, weighted, adjusted, include_transforms_for_dims,
                prune=prune,
            )
        # If there are no MR variables, the margins are mostly sums across
        # appropriate dimensions.
        transform_dims = self._margin_transform_dims(
            axis, include_transforms_for_dims,
        )
        array = self._as_array(
            weighted=weighted, adjusted=adjusted,
            include_transforms_for_dims=transform_dims,
            margin=True,
        )
        array = self._inflate_dim(array, axis)
        res = np.sum(array, axis)

        if prune and axis is not None and type(res) is np.ndarray:
            table = self.as_array(
                include_transforms_for_dims=include_transforms_for_dims,
                prune=prune,
            )
            mask = table.mask
            if isinstance(axis, tuple) or axis < mask.ndim:
                mask = mask.all(axis=axis)
            res = np.ma.masked_array(res, mask=mask)

        if len(res.shape) == 0:
            # Each margin needs to be iterable, even if it only has
            # a single element.
            res = res[np.newaxis]

        return res

    def _mr_props_as_0th(self, axis, table, hs_dims, prune):
        if len(table.shape) == 4:
            # This is the case of MR x CA, special treatment
            # Always return only the column direction (across CATs).
            num = self.as_array(
                include_transforms_for_dims=hs_dims,
                prune=prune,
            )
            den = self.margin(
                axis=1,
                include_transforms_for_dims=hs_dims
            )[:, None, :]
            return num / den

        # The following are normal MR x something (not CA)
        num = self.as_array(include_transforms_for_dims=hs_dims)
        if axis == 0:
            den = self.margin(
                axis=axis,
                include_transforms_for_dims=hs_dims
            )
        else:
            den = self.margin(axis=axis)[:, np.newaxis]
        return num / den

    def _mr_props_as_1st(self, axis, table, hs_dims, prune):
        num = table[self.ind_selected][np.ix_(*self.valid_indices)]
        non_selected = table[self.ind_non_selected][np.ix_(*self.valid_indices)]
        if num.ndim >= 3:
            if axis == (1, 2) or axis is None:
                den = np.sum(num + non_selected, 2)[:, :, None]
            elif axis == 2:
                den = np.sum(num, 2)[:, :, None]
            elif axis == 1:
                den = num + non_selected
            res = num / den
            res = self._transform(res, hs_dims, None)
            return res
        if axis == 0:
            den = np.sum(num, 0)
        elif axis == 1 or axis == 2 and len(num.shape) >= 3:
            den = num + non_selected
        else:
            axis = 0 if len(num.shape) < 3 else (1, 2)
            den = np.sum(num + non_selected, axis)
        res = num / den
        res = self._transform(res, hs_dims, None)
        if prune:
            res = np.ma.masked_array(res, mask=self.as_array(prune=prune).mask)
        return res

    def _mr_props_as_2nd(self, axis, hs_dims):
        margin = (
            self.margin(axis=axis)[:, np.newaxis]
            if axis == 1 else
            self.margin(axis=0)
        )
        return self.as_array(
            include_transforms_for_dims=hs_dims
        ) / margin

    def _mr_props_single_dim(self, table, valid_indices, prune):
        res = table[:, 0] / (table[:, 0] + table[:, 1])
        res = res[np.ix_(*valid_indices)]
        if prune:
            res = np.ma.masked_array(res, mask=(res == 0))
        return res

    def _mr_proportions(self, axis, weighted, prune, hs_dims=None):
        '''Calculate MR proportions.'''

        if self.is_double_mr:
            # For the case of MR x MR cube, proportions are calculated in a
            # specific way, which needs to be handled speparately.
            return self._double_mr_proportions(axis, weighted)

        table = self.table.data(weighted)
        valid_indices = [dim.valid_indices(False) for dim in self.dimensions]

        if self.ndim == 1:
            return self._mr_props_single_dim(table, valid_indices, prune)

        if self.mr_dim_ind == 0:
            return self._mr_props_as_0th(axis, table, hs_dims, prune)
        elif self.mr_dim_ind == 1:
            return self._mr_props_as_1st(axis, table, hs_dims, prune)
        else:
            return self._mr_props_as_2nd(axis, hs_dims)

    @property
    def is_univariate_ca(self):
        '''Check if cube is a just the CA ("ca x cat" or "cat x ca" dims)'''
        types = {d.type for d in self.dimensions}
        ca_types = {'categorical_array', 'categorical'}
        return self.ndim == 2 and types == ca_types

    @property
    def univariate_ca_main_axis(self):
        '''For univariate CA, the main axis is the categorical axis'''
        dim_types = [dim.type for dim in self.dimensions]
        return dim_types.index('categorical')

    def _proportions(self, axis=None, weighted=True, adjusted=False,
                     include_transforms_for_dims=None, include_missing=False,
                     prune=False):
        if self.has_mr:
            return self._mr_proportions(
                axis, weighted, prune,
                hs_dims=include_transforms_for_dims
            )

        if self.is_univariate_ca and axis != self.univariate_ca_main_axis:
            raise ValueError('CA props only defined for main axis direction.')

        margin = self._margin(
            axis=axis, weighted=weighted, adjusted=adjusted,
            include_transforms_for_dims=include_transforms_for_dims,
            prune=prune,
        )
        if axis == 1:
            margin = margin[:, np.newaxis]
        elif axis == 2:
            margin = margin[:, :, np.newaxis]

        array = self._as_array(
            include_missing=include_missing,
            weighted=weighted,
            adjusted=adjusted,
            include_transforms_for_dims=include_transforms_for_dims,
            prune=prune,
        )

        # In case of 3D cube, where each slice needs to be divided by a total
        # (margin) of each slice, we need to restore two dimensions of the
        # margin, to enable broadcasting and thus division.
        if (len(getattr(array, 'shape', [])) == 3 and
                len(getattr(margin, 'shape', [])) == 1):
            margin = margin[:, np.newaxis, np.newaxis]

        res = array / margin
        if isinstance(array, np.ma.core.MaskedArray):
            res.mask = array.mask
        return self._fix_shape(res)

    def _mr_dim_ind(self, include_selections=False):
        dimensions = (
            self.table.all_dimensions
            if include_selections else
            self.dimensions
        )
        indices = [
            i for i, dim in enumerate(dimensions)
            if dim.type == 'multiple_response'
        ]
        if indices:
            return indices[0] if len(indices) == 1 else tuple(indices)
        return None

    # Properties

    @property
    def ndim(self):
        return len(self.dimensions)

    @property
    def table(self):
        return self._table

    @property
    def ind_selected(self):
        return self._get_mr_slice()

    @property
    def ind_non_selected(self):
        return self._get_mr_slice(selected=False)

    @property
    def mr_dim_ind(self):
        '''Indices of MR dimensions.'''
        return self._mr_dim_ind()

    @property
    def standardized_residuals(self):
        '''Calculate residuals based on Chi-squared.'''

        if self.has_mr:
            return self.mr_std_residuals

        counts = self.as_array()
        total = self.margin()
        colsum = self.margin(axis=0)
        rowsum = self.margin(axis=1)
        expected_counts = expected_freq(counts)
        residuals = counts - expected_counts
        variance = (
            np.outer(rowsum, colsum) * np.outer(total - rowsum, total - colsum) / total**3
        )
        return residuals / np.sqrt(variance)

    @property
    def valid_indices(self):
        '''Valid indices of all dimensions (exclude missing).'''
        return [dim.valid_indices(False) for dim in self.dimensions]

    @property
    def mr_std_residuals(self):
        counts = self.as_array()
        total = self.margin()
        colsum = self.margin(axis=0)
        rowsum = self.margin(axis=1)

        if not self.is_double_mr and self.mr_dim_ind == 0:
            total = total[:, np.newaxis]
            rowsum = rowsum[:, np.newaxis]

        expected = rowsum * colsum / total
        variance = (
            rowsum * colsum * (total - rowsum) * (total - colsum) / total**3
        )
        return (counts - expected) / np.sqrt(variance)

    @property
    def has_mr(self):
        '''Determines if a cube has MR dimensions.'''
        return self.mr_dim_ind is not None

    @property
    def ca_dim_ind(self):
        for (i, dim) in enumerate(self.dimensions):
            if dim.type == 'categorical_array':
                return i
        else:
            return None

    @property
    def name(self):
        '''Return the name of the cube.

        If the cube has 2 diensions, return the name of the second one. In case
        of a different number of dimensions, default to returning the name of
        the last one. In case of no dimensions, return the empty string.
        '''
        if not self.dimensions:
            return None
        return self.dimensions[0].name

    @property
    def description(self):
        '''Return the description of the cube.'''
        if not self.dimensions:
            return None
        return self.dimensions[0].description

    @property
    def dimensions(self):
        '''Dimensions of the crunch cube.'''
        all_dimensions = self.table.all_dimensions
        mr_selections = self.table.mr_selections_indices
        return [
            dim for (i, dim) in enumerate(all_dimensions)
            if i not in mr_selections
        ]

    @property
    def missing(self):
        '''Get missing count of a cube.'''
        return self.table.missing

    @property
    def is_weighted(self):
        '''Check if the cube dataset is weighted.'''
        return self.table.is_weighted

    @property
    def filter_annotation(self):
        '''Get cube's filter annotation.'''
        return self.table.filter_annotation

    @property
    def has_means(self):
        '''Check if cube has means.'''
        return self.table.has_means

    @property
    def is_double_mr(self):
        '''Check if cube has 2 MR dimensions.'''
        return True if isinstance(self.mr_dim_ind, tuple) else False

    @property
    def double_mr_non_selected_inds(self):
        '''Gets all combinations of non-selected slices for any double MR cube.

        For double MR cubes, we need combinations of (selected) with
        (selected + non_selected) for all combinations of MR x MR, but we also
        need other potential dimensions included
        '''
        # This represents an index in between MR dimensions (at this point we
        # know there are two). It's used subsequently, for creating the
        # combined conditional slices, where we have to take 'selected' for
        # one MR, and selected AND non-selected for the other.
        inflect = self.mr_dim_ind[1] + 1
        ind_ns_0 = self.ind_selected[:inflect] + self.ind_non_selected[inflect:]
        ind_ns_1 = self.ind_non_selected[:inflect] + self.ind_selected[inflect:]
        return self.ind_non_selected, ind_ns_0, ind_ns_1

    # Static methods

    @staticmethod
    def _adjust_inserted_indices(inserted_indices_list, prune_indices_list):
        '''Adjust inserted indices, if there are pruned elements.'''
        pruned_and_inserted = zip(prune_indices_list, inserted_indices_list)
        for prune_inds, inserted_inds in pruned_and_inserted:
            # Only prune indices if they're not H&S (inserted)
            prune_inds = prune_inds[~np.in1d(prune_inds, inserted_inds)]
            for i, ind in enumerate(inserted_inds):
                ind -= np.sum(prune_inds < ind)
                inserted_inds[i] = ind
        return inserted_indices_list

    def _insertions(self, result, dimension, dimension_index):
        insertions = []

        for indices in dimension.hs_indices:
            ind_subtotal_elements = np.array(indices['inds'])

            if indices['anchor_ind'] == 'top':
                ind_insertion = -1
            elif indices['anchor_ind'] == 'bottom':
                ind_insertion = result.shape[dimension_index] - 1
            else:
                ind_insertion = indices['anchor_ind']

            ind = (
                [slice(None) for _ in range(dimension_index)] +
                [ind_subtotal_elements]
            )
            axis = dimension_index

            # no indices are provided (should never get here)
            if len(indices['inds']) == 0:
                value = 0
            else:
                value = np.sum(result[ind], axis=axis)
                insertions.append((ind_insertion, value))

        return insertions

    # API Functions

    def inserted_hs_indices(self, prune=False):
        '''Get indices of the inserted H&S (for formatting purposes).'''

        if self.ndim == 2 and prune:
            # If pruning is applied, we need to subtract from the H&S indes
            # the number of pruned rows (cols) that come before that index.
            margins = [
                self.margin(axis=i, include_transforms_for_dims=[0, 1])
                for i in [1, 0]
            ]
            margins = [
                margin if margin.ndim == 1 else np.sum(margin, axis=(1 - i))
                for i, margin in enumerate(margins)
            ]
            # Obtain prune indices as subscripts
            prune_indices_list = [
                np.arange(len(margin))[
                    np.logical_or(margin == 0, np.isnan(margin))
                ]
                for margin in margins
            ]
            inserted_indices_list = [
                dim.inserted_hs_indices for dim in self.dimensions
            ]
            return self._adjust_inserted_indices(inserted_indices_list,
                                                 prune_indices_list)

        return [dim.inserted_hs_indices for dim in self.dimensions]

    def labels(self, include_missing=False, include_transforms_for_dims=False):
        '''Gets labels for each cube's dimension.

        Args
            include_missing (bool): Include labels for missing values

        Returns
            labels (list of lists): Labels for each dimension
        '''
        return [
            dim.labels(include_missing, include_transforms_for_dims)
            for dim in self.dimensions
        ]

    def as_array(self, include_missing=False, weighted=True, adjusted=False,
                 include_transforms_for_dims=None, prune=False, margin=False):
        '''Get crunch cube as ndarray.

        Returns the tabular representation of the crunch cube. The returning
        value has as many dimensions, as there are dimensions in the crunch
        cube itself. E.g. for a cross-tab representation of a categorical and
        numerical variable, the resulting cube will have two dimensions.

        Args
            include_missing (bool): Include rows/cols for missing values
        Returns
            (ndarray): Tabular representation of the crunch cube

        Example 1 (Categorical x Categorical):
            >>> cube = CrunchCube(response)
            >>> cube.as_array()
            np.array([
                [5, 2],
                [5, 3],
            ])

        Example 2 (Categorical x Categorical, include missing values):
            >>> cube = CrunchCube(response)
            >>> cube.as_array(include_missing=True)
            np.array([
                [5, 3, 2, 0],
                [5, 2, 3, 0],
                [0, 0, 0, 0],
            ])
        '''
        array = self._as_array(
            include_missing=include_missing,
            weighted=weighted,
            adjusted=adjusted,
            include_transforms_for_dims=include_transforms_for_dims,
            prune=prune,
            margin=margin,
        )
        return self._fix_shape(array)

    def margin(self, axis=None, weighted=True,
               include_transforms_for_dims=None, prune=False):
        '''Get margin for the selected axis.

        the selected axis. For MR variables, this is the sum of the selected
        and non-selected slices.

        Args
            axis (int): Axis across the margin is calculated. If no axis is
                        provided the margin is calculated across all axis.
                        For Categoricals, Num, Datetime, and Text, this
                        translates to sumation of all elements.
        Returns
            Calculated margin for the selected axis

        Example 1:
            >>> cube = CrunchCube(fixt_cat_x_cat)
            np.array([
               [5, 2],
               [5, 3],
            ])

            >>> cube.margin(axis=0)
            np.array([10, 5])

        Example 2:
            >>> cube = CrunchCube(fixt_cat_x_num_x_datetime)
            np.array([
                [[1, 1],
                 [0, 0],
                 [0, 0],
                 [0, 0]],
                [[2, 1],
                 [1, 1],
                 [0, 0],
                 [0, 0]],
                [[0, 0],
                 [2, 3],
                 [0, 0],
                 [0, 0]],
                [[0, 0],
                 [0, 0],
                 [3, 2],
                 [0, 0]],
                [[0, 0],
                 [0, 0],
                 [1, 1],
                 [0, 1]]
            ])

            >>> cube.margin(axis=0)
            np.array([
                [3, 2],
                [3, 4],
                [4, 3],
                [0, 1],
            ])
        '''
        return self._margin(
            axis=axis,
            weighted=weighted,
            adjusted=False,
            include_transforms_for_dims=include_transforms_for_dims,
            prune=prune,
        )

    def proportions(self, axis=None, weighted=True,
                    include_transforms_for_dims=None, include_missing=False,
                    prune=False):
        '''Get proportions of a crunch cube.

        This function calculates the proportions across the selected axis
        of a crunch cube. For most variable types, it means the value divided
        by the margin value. For Multiple Response types, the value is divied
        by the sum of selected and non-selected slices.

        Args
            axis (int): Base axis of proportions calculation. If no axis is
                        provided, calculations are done accros entire table.
            weighted (bool): Do weighted or non-weighted proportions.
            include_transforms_for_dims (list): Also include headings and
                        subtotals transformations for the provided dimensions.
                        If the dimensions have the transformations, they'll be
                        included in the resulting numpy array. If the
                        dimensions don't have the transformations, nothing will
                        happen (the result will be the same as if the argument
                        weren't provided).
            include_transforms_for_dims (list): Include headers and subtotals
                        across various dimensions. The dimensions are provided
                        as list elements. For example:
                        "include_transforms_for_dims=[0, 1]" instructs the
                        CrunchCube to return H&S for both rows and columns
                        (if it's a 2D cube).
            include_missing (bool): Include missing categories
            prune (bool): Instructs the CrunchCube to prune empty rows/cols.
                        Emptiness is determined by the state of the margin
                        (if it's either 0 or nan at certain index). If it is,
                        the corresponding row/col is not included in the result.

        Returns
            (nparray): Calculated array of crunch cube proportions.

        Example 1:
            >>> cube = CrunchCube(fixt_cat_x_cat)
            np.array([
               [5, 2],
               [5, 3],
            ])

            >>> cube.proportions()
            np.array([
                [0.3333333, 0.1333333],
                [0.3333333, 0.2000000],
            ])

        Example 2:
            >>> cube = CrunchCube(fixt_cat_x_cat)
            np.array([
               [5, 2],
               [5, 3],
            ])

            >>> cube.proportions(axis=0)
            np.array([
                [0.5, 0.4],
                [0.5, 0.6],
            ])
        '''

        return self._proportions(
            axis=axis,
            weighted=weighted,
            adjusted=False,
            include_transforms_for_dims=include_transforms_for_dims,
            include_missing=include_missing,
            prune=prune,
        )

    def percentages(self, axis=None):
        '''Get the percentages for crunch cube values.

        This function calculates the percentages for crunch cube values. The
        percentages are based on the values of the 'proportions'.

        Args
            axis (int): Base axis of percentages calculation. If no axis is
                        provided, calculations are done accros entire table.

        Returns
            (nparray): Calculated array of crunch cube percentages.

        Example 1:
            >>> cube = CrunchCube(fixt_cat_x_cat)
            np.array([
               [5, 2],
               [5, 3],
            ])

            >>> cube.percentages()
            np.array([
                [33.33333, 13.33333],
                [33.33333, 20.00000],
            ])

        Example 2:
            >>> cube = CrunchCube(fixt_cat_x_cat)
            np.array([
               [5, 2],
               [5, 3],
            ])

            >>> cube.percentages(axis=0)
            np.array([
                [50., 40.],
                [50., 60.],
            ])
        '''
        return self.proportions(axis) * 100

    def population_counts(self, population_size, weighted=True,
                          include_missing=False,
                          include_transforms_for_dims=None, prune=False):
        '''Get population counts relative to the total population size estimate.
        This function calculates the population counts for crunch cube values.
        The population counts are based on the values of the 'proportions'.
        Args
            population_size (int): Estimated total population size
            weighted (bool): see proportions method
            include_missing (bool): see proportions  method
            include_transforms_for_dims (list): see proportions method
            prune (bool): see proportions method
        Returns
            (nparray): Calculated array of crunch cube population counts.
        Example:
            >>> cube = CrunchCube(fixt_cat_x_cat)
            >>> cube.as_array()
            np.array([
               [5, 2],
               [5, 3],
            ])
            >>> cube.population_counts(9000)
            np.array([
                [3000, 1200],
                [3000, 1800],
            ])
        '''
        return self._proportions(
            adjusted=False,
            weighted=weighted,
            include_missing=include_missing,
            include_transforms_for_dims=include_transforms_for_dims,
            prune=prune
        ) * population_size

    @property
    def pvals(self):
        '''Calculate p-vals.

        This function calculates statistically significant results for
        categorical contingency tables. The values can be calculated across
        columns (axis = 0), or across rows (axis = 1).

        Returns
            (ndarray): 2-Dimensional array, representing the p-values for each
                       cell of the table-like representation of the
                       crunch cube.
        '''
        stats = self.standardized_residuals
        return 2 * (1 - norm.cdf(np.abs(stats)))

    def y_offset(self, expand=False, include_transforms_for_dims=None):
        '''Gets y offset for sheet manipulation.

        Args:
            - expand (bool): If a cube is a categorical array, and it's also a
                0-index cube of multiple cube sequence, it needs to be
                displayed in a specific manner (sliced across categories
                dimension). This argument enables such behavior. If a CA cube
                is the only one (not a part of the multitable), it is output
                normally, without expansion.
        '''
        if not self.dimensions:
            return 4

        first_dim_length = self.as_array(
            include_transforms_for_dims=include_transforms_for_dims
        ).shape[0]

        # Special case of CA as a 0-ind cube
        if expand and self.dimensions[0].type == 'categorical_array':
            return first_dim_length * (len(self.dimensions[1].elements()) + 4)

        if self.ndim <= 2 and self.dimensions[0].type:
            return first_dim_length + 4
        return first_dim_length * (self.as_array(
            include_transforms_for_dims=include_transforms_for_dims
        ).shape[1] + 4)

    def count(self, weighted=True):
        '''Get cube's count with automatic weighted/unweighted selection.'''
        return self.table.count(weighted)

    def index(self, weighted=True, prune=False):
        '''Get cube index measurement.'''
        return Index(self, weighted, prune).data

    def scale_means(self):
        '''Get cube means.'''
        return ScaleMeans(self).data
