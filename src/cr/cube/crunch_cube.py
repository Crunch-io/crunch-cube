'''Home of the CrunchCube class.

This module contains the definition of the CrunchCube class. It represents
the open-source library used for manipulating the crunch cubes (JSON responses
from the Crunch.io platform).
'''
from __future__ import division

import json

import numpy as np
from scipy.stats import norm
from scipy.stats.contingency import expected_freq

from .dimension import Dimension


class CrunchCube(object):
    '''Implementation of the CrunchCube API class.

    Class is used for the implementation of the main API functions that are
    needed for seamless integration with the crunch cube responses
    (from Crunch.io platform).

    Main API functions are:
      - as_array
      - margin
      - proportions
      - percentages

    These functions are used to retrieve statistical information of interest,
    from the JSON like crunch cubes. Complete usage of each API function is
    described within the appropriate docstring.

    Crunch Cubes contain richer metadata than standart Python objects, and
    they also conceal certain complexity in the data structures from the user.
    In particular, Multiple Response variables are generally represented as
    single dimensions in result tables, but in the actual data, they may
    comprise of two dimensions. These methods (API) understand the subtleties
    in the Crunch data types, and correctly compute margins and
    percentages off of them.
    '''

    def __init__(self, response):
        '''Initializes the CrunchCube class with the cube JSON response.

        Class can be initialized with both JSON string, and dict types.
        There's no real parsing of the data at the point of initialization,
        just storing. The functionality is implemented in the
        appropriate API functions.
        '''
        # @cube: Represents the cube response object, as generated by
        # the zz9d cube factory. Cube can come in as a JSON or as a dictionary,
        # So we need to check its type, and convert it to a dictionary if
        # it's JSON, if possible.

        # If the provided response is dict, create cube immediately
        if isinstance(response, dict):
            self._cube = response.get('value', response)
            return

        try:
            response = json.loads(response)
            self._cube = response.get('value', response)
        except TypeError:
            # If an unexpected type is provided raise descriptive exception.
            if not isinstance(response, dict):
                raise TypeError((
                    'Unsupported type provided: {}. '
                    'A `cube` must be JSON or `dict`.'
                ).format(type(response)))

    @classmethod
    def _get_dimensions(cls, cube):
        '''Gets the dimensions of the crunch cube.

        This function is internal, and is not mean to be used by ouside users
        of the CrunchCube class. The main reason for this is the internal
        representation of the different variable types (namely the MR and the
        CA). These types have two dimensions each, but in the case of MR, the
        second dimensions shouldn't be visible to the user. This function
        returns such dimensions as well, since they're necessary for the
        correct implementation of the functionality for the MR type.
        The version that is mentioned to be used by users is the
        property 'dimensions'.
        '''
        entries = cube['result']['dimensions']
        return [
            (
                # Multiple Response and Categorical Array variables have
                # two subsequent dimensions (elements and selections). For
                # this reason it's necessary to pass in both of them in the
                # Dimension class init method. This is needed in order to
                # determine the correct type (CA or MR). We only skip the
                # two-argument constructor for the last dimension in the list
                # (where it's not possible to fetch the subsequent one).
                Dimension(entry)
                if i + 1 >= len(entries)
                else Dimension(entry, entries[i + 1])
            )
            for (i, entry) in enumerate(entries)
        ]

    @classmethod
    def _get_mr_selections_indices(cls, dimensions):
        '''Gets indices of each 'selection' dim, for corresponding MR dim.

        Multiple Response (MR) and Categorical Array (CA) variables are
        represented by two dimensions each. These dimensions can be thought of
        as 'elements' and 'selections'. This function returns the indices of
        the 'selections' dimension for each MR variable.
        '''
        mr_dimensions_indices = [
            i for (i, dim) in enumerate(dimensions)
            if (i + 1 < len(dimensions) and
                dim.type == 'multiple_response')
        ]
        # For each MR and CA dimension, the 'selections' dimension
        # follows right after it (in the originating cube).
        # Here we increase the MR index by 1, which gives us
        # the index of the corresponding 'selections' dimension.
        return [i + 1 for i in mr_dimensions_indices]

    @classmethod
    def _get_valid_indices(cls, dimensions, include_missing, get_non_selected):
        '''Gets valid indices for each dimension.

        Main criterion for a valid index is most often the information about
        whether the corresponding value of the dimension is missing or not.
        For MR variables, since they use two dimensions, the valid index
        for the 'selections' dimensions is [0], except in the case of
        non-selected slices calculation, where it needs to be [1].
        '''
        valid_indices = [dim.valid_indices(include_missing)
                         for dim in dimensions]

        mr_selections_indices = cls._get_mr_selections_indices(dimensions)
        mr_slice = [1] if get_non_selected else [0]
        if mr_selections_indices:
            # In the case of MR variables, we only need to select the
            # 'selected' slice of the 'selections' dimension.
            valid_indices = [
                (
                    valid_indices[i]
                    if i not in mr_selections_indices
                    else mr_slice
                )
                for (i, _) in enumerate(valid_indices)
            ]

        return valid_indices

    @classmethod
    def _fix_shape(cls, array):
        '''Fixes shape of MR variables.
        For MR variables, where 'selections' dims are dropped, the ndarray
        needs to be reshaped, in order to seem as if those dims never existed.
        '''

        # If a first dimension only has one element, we don't want to
        # remove it. Hence the i == 0 part.
        new_shape = [dim for (i, dim) in enumerate(array.shape)
                     if dim != 1 or i == 0]
        return array.reshape(new_shape)

    def _get_values(self, weighted):
        if self.has_means:
            values = self._cube['result']['measures']['mean']['data']
        elif not weighted or not self.is_weighted:
            values = self._cube['result']['counts']
        else:
            values = self._cube['result']['measures']['count']['data']

        values = [(val if not isinstance(val, dict) else np.nan)
                  for val in values]
        return values

    def _get_table(self, weighted):
        values = self._get_values(weighted)
        all_dimensions = self._get_dimensions(self._cube)
        shape = [len(dim.elements(include_missing=True))
                 for dim in all_dimensions]
        return np.array(values).reshape(shape)

    def _as_array(self, include_missing=False, get_non_selected=False,
                  weighted=True, adjusted=False,
                  include_transforms_for_dims=False,
                  prune=False):
        '''Get crunch cube as ndarray.

        Args
            include_missing (bool): Include rows/cols for missing values
            get_non_selected (bool): Get non-selected slices for MR vars
        Returns
            res (ndarray): Tabular representation of crunch cube
        '''
        values = self._get_values(weighted)
        all_dimensions = self._get_dimensions(self._cube)
        shape = [len(dim.elements(include_missing=True))
                 for dim in all_dimensions]
        valid_indices = self._get_valid_indices(
            all_dimensions,
            include_missing,
            get_non_selected
        )
        res = np.array(values).reshape(shape)
        if include_transforms_for_dims:
            for (i, dim) in enumerate(all_dimensions):

                # Check if transformations can/need to be performed
                transform = (dim.has_transforms and
                             i in include_transforms_for_dims)
                if not transform or dim.type == 'categorical_array':
                    continue

                # Perform transformations
                ind_offset = 0
                for indices in dim.hs_indices:
                    ind_subtotal_elements = np.array(indices['inds'])
                    ind_insertion = indices['anchor_ind'] + ind_offset
                    ind_subtotal_elements = (np.array(ind_subtotal_elements) +
                                             ind_offset)
                    if i == 0:
                        value = sum(res[ind_subtotal_elements])
                        res = np.insert(res, ind_insertion + 1, value, axis=i)
                    else:
                        value = np.sum(res[:, ind_subtotal_elements], axis=1)
                        res = np.insert(res, ind_insertion + 1, value, axis=i)
                    valid_indices = self._fix_valid_indices(valid_indices,
                                                            ind_insertion, i)
                    ind_offset += 1

        res = res[np.ix_(*valid_indices)]

        adjustment = 1 if adjusted else 0
        res = self._fix_shape(res) + adjustment

        if prune and not self.has_mr:
            # Remove columns and rows where marginal value is 0 or np.nan
            if len(self.dimensions) == 1:
                margin = self.margin(
                    include_transforms_for_dims=include_transforms_for_dims,
                    axis=1,
                )
                ind_prune = np.logical_or(margin == 0, np.isnan(margin))
                return res[~ind_prune]

            col_margin = self.margin(
                include_transforms_for_dims=include_transforms_for_dims,
                axis=0,
            )
            ind_prune = np.logical_or(col_margin == 0, np.isnan(col_margin))
            res = res[:, ~ind_prune]
            row_margin = self.margin(
                include_transforms_for_dims=include_transforms_for_dims,
                axis=1
            )
            ind_prune = np.logical_or(row_margin == 0, np.isnan(row_margin))
            return res[~ind_prune, :]

        return res

    @classmethod
    def _fix_valid_indices(cls, valid_indices, insertion_index, dim):
        indices = np.array(sorted(valid_indices[dim]))
        slice_index = np.sum(indices <= insertion_index)
        indices[slice_index:] += 1
        indices = np.insert(indices, slice_index, insertion_index + 1)
        valid_indices[dim] = indices.tolist()
        return valid_indices

    @classmethod
    def _calculate_constraints_sum(cls, prop_table, prop_margin, axis):
        '''Calculate sum of constraints (part of the standard error equation).

        This method calculates the sum of the cell proportions multiplied by
        row (or column) marginal proportions (margins divide by the total
        count). It does this by utilizing the matrix multiplication, which
        directly translates to the mathematical definition (the sum
        across i and j indices).
        '''
        if axis not in [0, 1]:
            raise ValueError('Unexpected value for `axis`: {}'.format(axis))

        V = prop_table * (1 - prop_table)
        if axis == 0:
            # If axis is 0, sumation is performed across the 'i' index, which
            # requires the matrix to be multiplied from the right
            # (because of the inner matrix dimensions).
            return np.dot(V, prop_margin)
        elif axis == 1:
            # If axis is 1, sumation is performed across the 'j' index, which
            # requires the matrix to be multiplied from the left
            # (because of the inner matrix dimensions).
            return np.dot(prop_margin, V)

    def _calculate_standard_error(self, axis, include_transforms_for_dims=None):
        total = self._margin(
            weighted=False,
            adjusted=True,
            include_transforms_for_dims=include_transforms_for_dims,
        )
        # Calculate margin across axis, as percentages of the total count
        margin = self._margin(
            axis=axis,
            weighted=False,
            adjusted=True,
            include_transforms_for_dims=include_transforms_for_dims
        ) / total
        # Adjusted proportions table, necessary for the standard error,
        # because of the division by it.
        props = self._proportions(
            axis=axis,
            weighted=False,
            adjusted=True,
            include_transforms_for_dims=include_transforms_for_dims
        )

        constraints = self._calculate_constraints_sum(props, margin, axis)
        if axis == 0:
            # If the s.e. is calculated across rows, the addition of the
            # 'constraints' member must be done element-wise, for 'magic_d' and
            # for each column of the props variance matrix, thus the
            # transformation to the column vector.
            constraints = constraints[:, np.newaxis]

        magic_d = (1 - 2 * margin) / margin
        if axis == 1:
            # If the s.e. is calculated across rows, the multiplication of
            # the 'magic_d' member must be done element-wise, for 'magic_d' and
            # for each row of the props variance matrix, thus the
            # transformation to the column vector.
            magic_d = magic_d[:, np.newaxis]

        return np.sqrt((magic_d * props * (1 - props) + constraints) / total)

    def _calculate_statistics(self, axis, include_transforms_for_dims=None):
        if axis not in [0, 1]:
            raise ValueError('Unexpected value for `axis`: {}'.format(axis))

        props = self.proportions(axis=axis, include_transforms_for_dims=include_transforms_for_dims)

        # Statistics are calculated by operating on both axes' margins. In this
        # function, we need to determine the cross-axis (other than the one
        # we're doing the calculation for), in order to be able to calculate
        # *that* margin, which will serve as the basis for the
        # statistics calculation.
        cross_axis = 0 if axis == 1 else 1
        cross_margin = self.margin(
            axis=cross_axis,
            include_transforms_for_dims=include_transforms_for_dims
        ) / self.margin(include_transforms_for_dims=include_transforms_for_dims)

        if cross_axis == 1:
            # If the row proportional margins are required, they also need to
            # be broadcast into the vector column shape, in order to be able to
            # perform the subtration from the matrix.
            cross_margin = cross_margin[:, np.newaxis]

        return (
            (props - cross_margin) /
            self._calculate_standard_error(axis, include_transforms_for_dims)
        )

    def _double_mr_proportions(self, axis, weighted):
        all_dimensions = self._get_dimensions(self._cube)
        shape = [len(dim.elements(include_missing=True))
                 for dim in all_dimensions]
        values = np.array(self._get_values(weighted)).reshape(shape)
        selected = values[:, 0, :, 0]

        if axis is None:
            non_selected = (values[:, 0, :, 1] + values[:, 1, :, 0] +
                            values[:, 1, :, 1])
        else:
            ind_sel, ind_non = 1 - axis, axis
            non_selected = values[:, ind_sel, :, ind_non]

        return selected / (selected + non_selected)

    @property
    def mr_dim_ind(self):
        for i, dim in enumerate(self.dimensions):
            if dim.type == 'multiple_response':
                return i
        return None

    @property
    def valid_indices(self):
        return [dim.valid_indices(False) for dim in self.dimensions]

    def _double_mr_margin(self, axis, weighted):
        table = self._get_table(weighted)
        selected = table[:, 0, :, 0]

        if axis is None:
            non_selected = (
                table[:, 1, :, 1] + table[:, 1, :, 0] + table[:, 0, :, 1]
            )
        elif axis == 0:
            non_selected = table[:, 1, :, 0]
        elif axis == 1:
            non_selected = table[:, 0, :, 1]

        return (selected + non_selected)[np.ix_(*self.valid_indices)]

    def _mr_margin(self, axis, weighted, adjusted):
        if self.is_double_mr:
            return self._double_mr_margin(axis, weighted)

        table = self._get_table(weighted)

        # In case of 1-D MR cube, we have reduced number of slices,
        # and separate 'if' is needed
        if len(self.dimensions) == 1:
            if axis == 0:
                return self.as_array(weighted=weighted)
            return table[:, 0] + table[:, 1]

        # For cases when margin is calculated along the axis which is not MR,
        # we need to perform sumation along that axis, on the tabular
        # representation of the cube (which is obtained with 'as_array').
        calculate_along_non_mr = (
            self.mr_dim_ind in [0, 2] and axis == 1 or
            self.mr_dim_ind == 1 and axis == 0 or
            self.mr_dim_ind == 1 and axis == 1 and len(self.dimensions) > 2
        )
        if calculate_along_non_mr:
            array = self.as_array(weighted=weighted)

            if axis == 1 and len(array.shape) == 1:
                # If array representation of the cube has less dimensions than
                # supposed (by the 'axis' argument), return the array. This
                # condition may arise if one of the cross variables of the cube
                # has only one element (e.g. in MR x CAT cube).
                return array

            return np.sum(array, axis)

        # For cases when the margin is calculated for the MR dimension, we need
        # the sum of selected and non-selected slices (if axis is None), or the
        # sublimated version (another sum along the axis), if axis is defined.
        ind_selected = tuple(
            0 if i - 1 == self.mr_dim_ind else slice(None)
            for (i, _) in enumerate(table.shape)
        )
        ind_non_selected = tuple(
            1 if i - 1 == self.mr_dim_ind else slice(None)
            for (i, _) in enumerate(table.shape)
        )
        margin = table[ind_selected] + table[ind_non_selected]
        margin = margin[np.ix_(*self.valid_indices)]

        return np.sum(margin, 1 - self.mr_dim_ind) if axis is None else margin

    def _margin(self, axis=None, weighted=True, adjusted=False,
                include_transforms_for_dims=None, prune=False):

        # MR margins are calculated differently, so they need a separate method
        # for them. A good example of this is the rcrunch functionality.
        if self.has_mr:
            return self._mr_margin(axis, weighted, adjusted)

        # If there are no MR variables, the margins are mostly sums across
        # appropriate dimensions.
        transform_dims = include_transforms_for_dims and (
            [(1 - axis)]
            if axis is not None and isinstance(axis, int)
            else None
        )
        array = self.as_array(
            weighted=weighted,
            adjusted=adjusted,
            include_transforms_for_dims=transform_dims,
            # prune=prune,
        )

        # Explicitly check if axis is tuple (which could be the case for doing
        # cell percentages across 3D cube, when the axis is set to (1, 2)).
        # Python 3 doesn't support tuple to int conversion, and we have to
        # check it manually.
        if (axis and not isinstance(axis, tuple) and
                axis > 0 and len(array.shape) == 1):
            # If any of the dimensions has only one element, it's flattened
            # from the resulting array (as a part of the MR pre-processing).
            # This can lead to a potential inconsistency between dimensions
            # and axes, and we need to restore one dimension in this case.
            array = array[:, np.newaxis]

        res = np.sum(array, axis)

        if prune:
            # Remove values if 0 or np.nan
            ind_prune = np.logical_or(res == 0, np.isnan(res))
            res = res[~ind_prune]

        if len(res.shape) == 0:
            # Each margin needs to be iterable, even if it only has
            # a single element.
            res = res[np.newaxis]

        return res

    def _mr_proportions(self, axis, weighted):
        if self.is_double_mr:
            # For the case of MR x MR cube, proportions are calculated in a
            # specific way, which needs to be handled speparately.
            return self._double_mr_proportions(axis, weighted)

        table = self._get_table(weighted)
        valid_indices = [dim.valid_indices(False) for dim in self.dimensions]

        if len(self.dimensions) == 1:
            res = table[:, 0] / (table[:, 0] + table[:, 1])
            return res[np.ix_(*valid_indices)]

        if self.dimensions[0].type == 'multiple_response':
            if len(table.shape) == 4:
                # This is the case of MR x CA, special treatment
                # Still haven'f figured out the percentages
                if axis == 1:
                    res = (table[:, 0, :, :] /
                           np.sum(table[:, 0, :, :], 1))
                else:
                    res = (table[:, 0, :, :] /
                           (table[:, 0, :, :] + table[:, 1, :, :]))

            # The following are normal MR x something (not CA)
            if axis == 1:
                return self.as_array() / self.margin(axis=1)[:, np.newaxis]
            else:
                res = table[:, 0, :] / (table[:, 0, :] + table[:, 1, :])
        elif self.dimensions[1].type == 'multiple_response':
            if axis == 0:
                res = table[:, :, 0] / np.sum(table[:, :, 0], 0)
            else:
                res = table[:, :, 0] / (table[:, :, 0] + table[:, :, 1])
        elif self.dimensions[2].type == 'multiple_response':
            margin = (
                self.margin(axis=axis)[:, np.newaxis]
                if axis == 1 else
                self.margin(axis=0)
            )
            return self.as_array() / margin

        return res[np.ix_(*valid_indices)]

    def _proportions(self, axis=None, weighted=True, adjusted=False,
                     include_transforms_for_dims=None, include_missing=False,
                     prune=False):
        if self.has_mr:
            return self._mr_proportions(axis, weighted)

        margin = self._margin(
            axis=axis,
            weighted=weighted,
            adjusted=adjusted,
            include_transforms_for_dims=include_transforms_for_dims,
            prune=prune,
        )
        if axis == 1:
            margin = margin[:, np.newaxis]
        elif axis == 2:
            margin = margin[:, :, np.newaxis]

        array = self.as_array(
            include_missing=include_missing,
            weighted=weighted,
            adjusted=adjusted,
            include_transforms_for_dims=include_transforms_for_dims,
            prune=prune,
        )

        # In case of 3D cube, where each slice needs to be divided by a total
        # (margin) of each slice, we need to restore two dimensions of the
        # margin, to enable broadcasting and thus division.
        if (len(getattr(array, 'shape', [])) == 3 and
                len(getattr(margin, 'shape', [])) == 1):
            margin = margin[:, np.newaxis, np.newaxis]

        return array / margin

    # Properties

    @property
    def _mr_std_residuals(self):
        counts = self.as_array()
        total = self.margin()
        colsum = self.margin(axis=0)
        rowsum = self.margin(axis=1)

        if not self.is_double_mr and self.mr_dim_ind == 0:
            total = total[:, np.newaxis]
            rowsum = rowsum[:, np.newaxis]

        expected = rowsum * colsum / total
        variance = (
            rowsum * colsum * (total - rowsum) * (total - colsum) / total**3
        )
        return (counts - expected) / np.sqrt(variance)

    @property
    def has_mr(self):
        '''Determines if a cube has MR dimensions.'''
        all_dimensions = self._get_dimensions(self._cube)
        mr_indices = self._get_mr_selections_indices(all_dimensions)
        return bool(mr_indices)

    @property
    def name(self):
        '''Return the name of the cube.

        If the cube has 2 diensions, return the name of the second one. In case
        of a different number of dimensions, default to returning the name of
        the last one. In case of no dimensions, return the empty string.
        '''
        if not self.dimensions:
            return None
        return self.dimensions[0].name

    @property
    def description(self):
        '''Return the description of the cube.'''
        if not self.dimensions:
            return None
        return self.dimensions[0].description

    @property
    def dimensions(self):
        '''Dimensions of the crunch cube.'''
        all_dimensions = self._get_dimensions(self._cube)
        mr_selections = self._get_mr_selections_indices(all_dimensions)
        return [
            dim for (i, dim) in enumerate(all_dimensions)
            if i not in mr_selections
        ]

    @property
    def missing(self):
        '''Get missing count of a cube.'''
        if self.has_means:
            return self._cube['result']['measures']['mean']['n_missing']
        return self._cube['result'].get('missing')

    @property
    def is_weighted(self):
        '''Check if the cube dataset is weighted.'''
        weighted = self._cube.get('query', {}).get('weight', None) is not None
        weighted = weighted or self._cube.get('weight_var', None) is not None
        weighted = weighted or self._cube.get('weight_url', None) is not None
        weighted = weighted or (
            self._cube['result']['counts'] !=
            self._cube['result']['measures'].get('count', {}).get('data')
        )
        return weighted

    @property
    def filter_annotation(self):
        '''Get cube's filter annotation.'''
        return self._cube.get('filter_names', [])

    @property
    def has_means(self):
        '''Check if cube has means.'''
        return self._cube['result']['measures'].get('mean', None) is not None

    @property
    def is_double_mr(self):
        '''Check if cube is MR x MR.'''
        types = [dim.type for dim in self.dimensions]
        if types == ['multiple_response', 'multiple_response']:
            return True
        return False

    # API Functions

    def labels(self, include_missing=False, include_transforms_for_dims=False):
        '''Gets labels for each cube's dimension.

        Args
            include_missing (bool): Include labels for missing values

        Returns
            labels (list of lists): Labels for each dimension
        '''
        return [
            dim.labels(include_missing, include_transforms_for_dims)
            for dim in self.dimensions
        ]

    def as_array(self, include_missing=False, weighted=True, adjusted=False,
                 include_transforms_for_dims=None, prune=False):
        '''Get crunch cube as ndarray.

        Returns the tabular representation of the crunch cube. The returning
        value has as many dimensions, as there are dimensions in the crunch
        cube itself. E.g. for a cross-tab representation of a categorical and
        numerical variable, the resulting cube will have two dimensions.

        Args
            include_missing (bool): Include rows/cols for missing values
        Returns
            (ndarray): Tabular representation of the crunch cube

        Example 1 (Categorical x Categorical):
            >>> cube = CrunchCube(response)
            >>> cube.as_array()
            np.array([
                [5, 2],
                [5, 3],
            ])

        Example 2 (Categorical x Categorical, include missing values):
            >>> cube = CrunchCube(response)
            >>> cube.as_array(include_missing=True)
            np.array([
                [5, 3, 2, 0],
                [5, 2, 3, 0],
                [0, 0, 0, 0],
            ])
        '''
        return self._as_array(
            include_missing=include_missing,
            weighted=weighted,
            adjusted=adjusted,
            include_transforms_for_dims=include_transforms_for_dims,
            prune=prune,
        )

    def margin(self, axis=None, weighted=True,
               include_transforms_for_dims=None, prune=False):
        '''Get margin for the selected axis.

        the selected axis. For MR variables, this is the sum of the selected
        and non-selected slices.

        Args
            axis (int): Axis across the margin is calculated. If no axis is
                        provided the margin is calculated across all axis.
                        For Categoricals, Num, Datetime, and Text, this
                        translates to sumation of all elements.
        Returns
            Calculated margin for the selected axis

        Example 1:
            >>> cube = CrunchCube(fixt_cat_x_cat)
            np.array([
               [5, 2],
               [5, 3],
            ])

            >>> cube.margin(axis=0)
            np.array([10, 5])

        Example 2:
            >>> cube = CrunchCube(fixt_cat_x_num_x_datetime)
            np.array([
                [[1, 1],
                 [0, 0],
                 [0, 0],
                 [0, 0]],
                [[2, 1],
                 [1, 1],
                 [0, 0],
                 [0, 0]],
                [[0, 0],
                 [2, 3],
                 [0, 0],
                 [0, 0]],
                [[0, 0],
                 [0, 0],
                 [3, 2],
                 [0, 0]],
                [[0, 0],
                 [0, 0],
                 [1, 1],
                 [0, 1]]
            ])

            >>> cube.margin(axis=0)
            np.array([
                [3, 2],
                [3, 4],
                [4, 3],
                [0, 1],
            ])
        '''
        return self._margin(
            axis=axis,
            weighted=weighted,
            adjusted=False,
            include_transforms_for_dims=include_transforms_for_dims,
            prune=prune,
        )

    def proportions(self, axis=None, weighted=True,
                    include_transforms_for_dims=None, include_missing=False,
                    prune=False):
        '''Get proportions of a crunch cube.

        This function calculates the proportions across the selected axis
        of a crunch cube. For most variable types, it means the value divided
        by the margin value. For Multiple Response types, the value is divied
        by the sum of selected and non-selected slices.

        Args
            axis (int): Base axis of proportions calculation. If no axis is
                        provided, calculations are done accros entire table.
            weighted (bool): Do weighted or non-weighted proportions.
            include_transforms_for_dims (list): Also include headings and
                        subtotals transformations for the provided dimensions.
                        If the dimensions have the transformations, they'll be
                        included in the resulting numpy array. If the
                        dimensions don't have the transformations, nothing will
                        happen (the result will be the same as if the argument
                        weren't provided).
            include_transforms_for_dims (list): Include headers and subtotals
                        across various dimensions. The dimensions are provided
                        as list elements. For example:
                        "include_transforms_for_dims=[0, 1]" instructs the
                        CrunchCube to return H&S for both rows and columns
                        (if it's a 2D cube).
            include_missing (bool): Include missing categories
            prune (bool): Instructs the CrunchCube to prune empty rows/cols.
                        Emptiness is determined by the state of the margin
                        (if it's either 0 or nan at certain index). If it is,
                        the corresponding row/col is not included in the result.

        Returns
            (nparray): Calculated array of crunch cube proportions.

        Example 1:
            >>> cube = CrunchCube(fixt_cat_x_cat)
            np.array([
               [5, 2],
               [5, 3],
            ])

            >>> cube.proportions()
            np.array([
                [0.3333333, 0.1333333],
                [0.3333333, 0.2000000],
            ])

        Example 2:
            >>> cube = CrunchCube(fixt_cat_x_cat)
            np.array([
               [5, 2],
               [5, 3],
            ])

            >>> cube.proportions(axis=0)
            np.array([
                [0.5, 0.4],
                [0.5, 0.6],
            ])
        '''

        return self._proportions(
            axis=axis,
            weighted=weighted,
            adjusted=False,
            include_transforms_for_dims=include_transforms_for_dims,
            include_missing=include_missing,
            prune=prune,
        )

    def percentages(self, axis=None):
        '''Get the percentages for crunch cube values.

        This function calculates the percentages for crunch cube values. The
        percentages are based on the values of the 'proportions'.

        Args
            axis (int): Base axis of percentages calculation. If no axis is
                        provided, calculations are done accros entire table.

        Returns
            (nparray): Calculated array of crunch cube percentages.

        Example 1:
            >>> cube = CrunchCube(fixt_cat_x_cat)
            np.array([
               [5, 2],
               [5, 3],
            ])

            >>> cube.percentages()
            np.array([
                [33.33333, 13.33333],
                [33.33333, 20.00000],
            ])

        Example 2:
            >>> cube = CrunchCube(fixt_cat_x_cat)
            np.array([
               [5, 2],
               [5, 3],
            ])

            >>> cube.percentages(axis=0)
            np.array([
                [50., 40.],
                [50., 60.],
            ])
        '''
        return self.proportions(axis) * 100

    def pvals(self, axis, include_transforms_for_dims=None):
        '''Calculate p-vals.

        This function calculates statistically signifficant results for
        categorical contingency tables. The values can be calculated across
        columns (axis = 0), or across rows (axis = 1).

        Args
            axis (int): Dimension across which to calculate the p-values.
                        0 - calculate across columns
                        1 - calculate across rows
        Returns
            (ndarray): 2-Dimensional array, representing the p-values for each
                       cell of the table-like representation of the
                       crunch cube.
        '''
        stats = self._calculate_statistics(axis, include_transforms_for_dims)
        sign = np.sign(stats)

        p_values = 2 * (1 - norm.cdf(np.abs(stats)))
        p_values *= sign

        return p_values

    def y_offset(self, expand=False):
        '''Gets y offset for sheet manipulation.

        Args:
            - expand (bool): If a cube is a categorical array, and it's also a
                0-index cube of multiple cube sequence, it needs to be
                displayed in a specific manner (sliced across categories
                dimension). This argument enables such behavior. If a CA cube
                is the only one (not a part of the multitable), it is output
                normally, without expansion.
        '''
        if not self.dimensions:
            return 4

        first_dim_length = self.as_array().shape[0]

        # Special case of CA as a 0-ind cube
        if expand and self.dimensions[0].type == 'categorical_array':
            return first_dim_length * (len(self.dimensions[1].elements()) + 4)

        if len(self.dimensions) <= 2 and self.dimensions[0].type:
            return first_dim_length + 4
        return first_dim_length * (self.as_array().shape[1] + 4)

    def count(self, weighted=True):
        '''Get cube's count with automatic weighted/unweighted selection.'''
        if weighted and self.is_weighted:
            return sum(
                self._cube['result']['measures'].get('count', {}).get('data')
            )
        return self._cube['result']['n']

    def _mr_index(self, axis, weighted):
        table = self._get_table(weighted)

        if self.dimensions[0].type == 'multiple_response':
            if axis != 0:
                # MR x CAT index table only defined for column direction.
                return np.full(self.as_array().shape, np.nan)
            selected = (
                table[:, 0, :, 0]
                if self.is_double_mr else
                table[:, 0, :]
            )
            non_selected = (
                table[:, 1, :, 1]
                if self.is_double_mr else
                table[:, 1, :]
            )
            margin = np.sum(selected, 1) / np.sum(selected + non_selected, 1)
            return (self.proportions(axis=axis, weighted=weighted) /
                    margin[:, np.newaxis])

        if self.dimensions[1].type == 'multiple_response':
            if axis == 0:
                # CAT x MR index table not defined for column direction.
                return np.full(self.as_array().shape, np.nan)

            selected = table[:, :, 0]
            non_selected = table[:, :, 1]
            margin = np.sum(selected, 0) / np.sum(selected + non_selected, 0)
            return self.proportions(weighted=weighted) / margin

        raise ValueError('Unexpected dimension types for cube with MR.')

    def index(self, axis, weighted=True, prune=False):
        '''Return table index by margin.'''

        if self.has_mr:
            return self._mr_index(axis, weighted)

        margin = (
            self.margin(axis=axis, weighted=weighted, prune=prune) /
            self.margin(weighted=weighted, prune=prune)
        )
        props = self.proportions(
            axis=(1 - axis),
            weighted=weighted,
            prune=prune,
        )

        if axis == 1:
            margin = margin[:, np.newaxis]

        return props / margin

    @property
    def standardized_residuals(self):
        '''Calculate residuals based on Chi-squared.'''

        if self.has_mr:
            return self._mr_std_residuals

        counts = self.as_array()
        total = self.margin()
        colsum = self.margin(axis=0) / total
        rowsum = self.margin(axis=1) / total
        expected_counts = expected_freq(counts)
        residuals = counts - expected_counts
        variance = (
            expected_counts *
            ((1 - rowsum[:, np.newaxis]) * (1 - colsum))
        )
        return residuals / np.sqrt(variance)
